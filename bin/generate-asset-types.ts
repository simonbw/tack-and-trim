import camelcase from "camelcase";
import chokidar from "chokidar";
import fs from "fs";
import { globSync } from "glob";
import path from "path";
import yargs from "yargs";

/** Template for generating the [assetName].d.ts files */
const individualFileTemplate = (varName: string) =>
  /*ts*/ `
// This file autogenerated by generate-asset-types.ts
// Do not modify it by hand. Any changes will be overwritten.
declare const ${varName}: string;
export default ${varName};
`.trimStart();

/** Template for generating the resources.ts manifest file. */
const manifestFileTemplate = (
  soundFiles: string[],
  imageFiles: string[],
  fontFiles: string[],
  levelFiles: string[],
  entityDefFiles: string[],
  jsonFiles: string[],
  varName: (file: string) => string
) =>
  /*ts*/ `
// This file autogenerated by generate-asset-types.js
// Do not modify it by hand. Any changes will be overwritten.
const sounds = {
${soundFiles
  .map((sound) => /*ts*/ `  ${varName(sound)}: require("url:${sound}")`)
  .join(",\n")}
};
export type SoundName = keyof typeof sounds;

const images = {
${imageFiles
  .map((image) => /*ts*/ `  ${varName(image)}: require("url:${image}")`)
  .join(",\n")}
};
export type ImageName = keyof typeof images;

const fonts = {
${fontFiles
  .map((font) => /*ts*/ `  ${varName(font)}: require("${font}")`)
  .join(",\n")}
};
export type FontName = keyof typeof fonts;

const levels = {
${levelFiles
  .map((level) => /*ts*/ `  ${varName(level)}: require("${level}")`)
  .join(",\n")}
};
export type LevelName = keyof typeof levels;

const entityDefs = {
${entityDefFiles
  .map((entityDef) => /*ts*/ `  ${varName(entityDef)}: require("${entityDef}")`)
  .join(",\n")}
}
export type EntityDefName = keyof typeof entityDefs;

const jsonBlobs = {
${jsonFiles
  .map((json) => /*ts*/ `  ${varName(json)}: require("${json}")`)
  .join(",\n")}
};

export const RESOURCES = { sounds, images, fonts, levels, entityDefs, jsonBlobs };
`.trimStart();

/*
 * Generates .d.ts files for all of our assets to provide stricter type
 * checking and nicer autocomplete when importing them.
 */
async function main() {
  // mapping extensions to their variable prefix
  const extensionToType = {
    // images
    bmp: "img",
    gif: "img",
    jpg: "img",
    png: "img",
    svg: "img",
    // fonts
    ttf: "fnt",
    otf: "fnt",
    woff: "fnt",
    woff2: "fnt",
    // audio
    flac: "snd",
    mp3: "snd",
    ogg: "snd",
    wav: "snd",
    // shaders
    frag: "frag",
    vert: "vert",
    //models
    gltf: "gltf",
    glb: "glb",
    //misc
    txt: "txt",
    json: "json",
  } as const;
  type FileExtension = keyof typeof extensionToType;
  type ResourceType = (typeof extensionToType)[FileExtension] | "res";

  const extensions = Object.keys(extensionToType);
  const extensionPattern = extensions.join("|");

  // The contents of the generated file
  function getContent(fileName: string) {
    const parts = path.basename(fileName).split(".");
    const baseVarName = camelcase(parts[0]);

    // the extension before the .d.ts
    const extension = parts.length > 3 ? parts[parts.length - 3] : "";
    const prefix = getResourceTypeFromExtension(extension);

    const varName = `${prefix}_${baseVarName}`;

    return individualFileTemplate(varName);
  }

  function getResourceTypeFromExtension(extension: string): ResourceType {
    if (extension in extensionToType) {
      return extensionToType[extension as FileExtension];
    } else {
      console.log("unknown extension", extension);
      return "res";
    }
  }

  // Removes old types
  function cleanTypes(assetsFolder: string, silent = false) {
    if (!silent) {
      console.log(
        `removing old asset .d.ts files from "${assetsFolder}" . . .`
      );
    }
    const pattern = `${assetsFolder}/**/*.@(${extensionPattern}).d.ts`;
    const fileNames = globSync(pattern, {});
    fileNames.forEach((fileName) => {
      if (!silent) {
        console.log(" - removed " + fileName);
      }
      fs.unlinkSync(fileName);
    });
    if (fileNames.length === 0 && !silent) {
      console.log("No files to remove");
    }
    return fileNames;
  }

  // Generates the new type files
  function generateTypes(assetsFolder: string, silent = false) {
    if (!silent) {
      console.log(
        `generating new asset .d.ts files in "${assetsFolder}" . . .`
      );
    }
    const pattern = `${assetsFolder}/**/*.@(${extensionPattern})`;
    const fileNames = globSync(pattern, {}).map((f) => f + ".d.ts");
    fileNames.forEach((fileName) => {
      fs.writeFileSync(fileName, getContent(fileName));
      if (!silent) {
        console.log(" - created " + fileName);
      }
    });
    if (fileNames.length === 0 && !silent) {
      console.log("No files to generate");
    }

    generateManifest(assetsFolder, silent);

    return fileNames;
  }

  function generateManifest(assetsFolder: string, silent = false) {
    const pattern = `${assetsFolder}/**/*.@(${extensionPattern})`;
    const fileNames = globSync(pattern, {}).map((f) => f);

    const soundFiles = [];
    const imageFiles = [];
    const fontFiles = [];
    const levelFiles = [];
    const entityDefFiles = [];
    const jsonFiles = [];

    for (const fileName of fileNames) {
      const parts = fileName.split(".");
      const extension = parts.length > 1 ? parts[parts.length - 1] : "";
      const resourceType = getResourceTypeFromExtension(extension);

      const relativePath = `./${path.relative(assetsFolder, fileName).replaceAll("\\", "/")}`;

      switch (resourceType) {
        case "snd":
          soundFiles.push(relativePath);
          break;
        case "img":
          imageFiles.push(relativePath);
          break;
        case "fnt":
          fontFiles.push(relativePath);
          break;
        case "json":
          if (fileName.includes("entity-defs/")) {
            entityDefFiles.push(relativePath);
          } else if (fileName.includes("levels/")) {
            levelFiles.push(relativePath);
          } else {
            jsonFiles.push(relativePath);
          }
          break;
      }
    }

    /** Get the variable name from a file path. */
    const varName = (filename: string) =>
      camelcase(path.basename(filename).split(".")[0]);

    const content = manifestFileTemplate(
      soundFiles,
      imageFiles,
      fontFiles,
      levelFiles,
      entityDefFiles,
      jsonFiles,
      varName
    );

    const manifestFile = `${assetsFolder}/resources.ts`;
    fs.writeFileSync(manifestFile, content);

    if (!silent) {
      console.log(`manifest at ${manifestFile}`);
    }
  }

  function cleanAndGenerate(assetsFolder: string) {
    const removed = new Set(cleanTypes(assetsFolder, true));
    const generated = new Set(generateTypes(assetsFolder, true));
    const newFiles = [];
    const deletedFiles = [];
    for (const fileName of removed) {
      if (!generated.has(fileName)) {
        deletedFiles.push(fileName);
      }
    }
    for (const fileName of generated) {
      if (!removed.has(fileName)) {
        newFiles.push(fileName);
      }
    }
    if (deletedFiles.length) {
      console.log(deletedFiles.map((f) => ` - removed ${f}`).join("\n"));
    }
    if (newFiles.length) {
      console.log(newFiles.map((f) => ` + created ${f}`).join("\n"));
    }
    if (newFiles.length === 0 && deletedFiles.length === 0) {
      console.log("Nothing has changed");
    }
  }

  function watch(assetsFolder: string) {
    const resourceGlob = `${assetsFolder}/**/*.{${extensions.join(",")}}`;
    console.log(`Watching for resource changes in ${resourceGlob}`);

    // Run once at the beginning
    cleanAndGenerate(assetsFolder);

    // Then run it on every new or removed file
    chokidar
      .watch(resourceGlob, { ignoreInitial: true })
      .on("add", (path, stats) => {
        cleanAndGenerate(assetsFolder);
      })
      .on("unlink", () => {
        cleanAndGenerate(assetsFolder);
      });
  }

  yargs(process.argv.slice(2))
    .scriptName("generate-asset-types")
    .usage(
      "Generates .d.ts files for assets to provide stricter type checking and nicer autocomplete when importing them."
    )
    .help()
    .option("directory", {
      alias: "d",
      describe: "Directory containing assets",
      default: "./src/assets",
      coerce: (d) => path.resolve(d),
      type: "string",
      normalize: true,
      global: true,
    })
    .command(
      "$0",
      "cleans and generates",
      () => {},
      (argv) => {
        console.log(`Updating asset types in "\${assetsFolder}" . . .`);
        cleanAndGenerate(argv.directory);
      }
    )
    .command(
      "watch",
      "keeps everything up to date",
      () => {},
      (argv) => {
        watch(argv.directory);
      }
    )
    .command(
      "clean",
      "removes all asset types",
      () => {},
      (argv) => {
        cleanTypes(argv.directory);
      }
    )
    .command(
      "generate",
      "generates new .d.ts files",
      () => {},
      (argv) => {
        generateTypes(argv.directory);
      }
    ).argv;
}

main();
